'use server'

import { z } from 'zod'
import { createAdminSupabaseClient } from '@/lib/supabase/admin-client'
import { revalidatePath } from 'next/cache'
import { Tables } from '@/types/supabase'
import { parseId, parseIdOrNull } from '@/lib/utils/id-parser'
import type { ActionResponse } from '@/types/admin/product'

type CategoryRow = Tables<'categories'>

export interface Category extends CategoryRow {
  parent?: CategoryRow | null
  children?: Category[]
  product_count?: number
}

export interface CategoryFormData {
  name: string
  slug: string
  description?: string
  parent_id?: string | number | null
  is_active: boolean
  display_order: number
  image_url?: string
  seo_title?: string
  seo_description?: string
}

// Form validation schema
const CategorySchema = z.object({
  name: z.string().min(1, 'Kategori adƒ± zorunludur'),
  slug: z.string().min(1, 'URL slug zorunludur'),
  description: z.string().optional(),
  parent_id: z.union([z.string(), z.number()]).transform(val => parseIdOrNull(val)).nullable().optional(),
  is_active: z.boolean(),
  display_order: z.number().int().min(0),
  image_url: z.string().optional(),
  seo_title: z.string().optional(),
  seo_description: z.string().optional()
})

// Kategorileri getir
export async function getCategories(): Promise<ActionResponse<Category[]>> {
  try {
    console.log('üîç [CATEGORIES] getCategories ba≈üladƒ±')
    const supabase = await createAdminSupabaseClient()
    console.log('‚úÖ [CATEGORIES] Supabase client olu≈üturuldu')
    
    // Simple query without complex chaining
    console.log('üîÑ [CATEGORIES] Query execute ediliyor...')
    const { data, error } = await supabase
      .from('categories')
      .select('*')
      .order('name', { ascending: true })
      
    console.log('üìã [CATEGORIES] Raw kategori data:', { 
      count: data?.length, 
      hasError: !!error,
      errorMsg: error?.message,
      sampleIds: data?.slice(0, 3).map(c => ({ id: c.id, name: c.name }))
    })

    if (error) {
      console.error('‚ùå [CATEGORIES] Kategori sorgu hatasƒ±:', error)
      throw error
    }

    // Kategorileri hiyerar≈üik yapƒ±ya d√∂n√º≈üt√ºr
    console.log('üîÑ [CATEGORIES] buildCategoryTree ba≈ülƒ±yor...')
    const categories = buildCategoryTree(data || [])
    console.log('‚úÖ [CATEGORIES] buildCategoryTree tamamlandƒ±:', {
      count: categories.length,
      sampleIds: categories.slice(0, 3).map(c => ({ id: c.id, name: c.name }))
    })
    
    return { 
      success: true, 
      data: categories,
      message: 'Kategoriler ba≈üarƒ±yla y√ºklendi'
    }
  } catch (error) {
    console.error('üí• Admin kategoriler getirilirken hata:', error)
    return { 
      success: false, 
      error: 'Kategoriler y√ºklenirken bir hata olu≈ütu' 
    }
  }
}

// Tek kategori getir
export async function getCategory(id: string): Promise<ActionResponse<Category>> {
  try {
    const supabase = await createAdminSupabaseClient()
    
    const { data, error } = await supabase
      .from('categories')
      .select('*, parent:parent_id(*)')
      .eq('id', id)
      .single()

    if (error) throw error
    if (!data) return { success: false, error: 'Kategori bulunamadƒ±' }

    return { 
      success: true, 
      data: data as Category,
      message: 'Kategori ba≈üarƒ±yla y√ºklendi'
    }
  } catch (error) {
    console.error('Kategori getirilirken hata:', error)
    return { 
      success: false, 
      error: 'Kategori y√ºklenirken bir hata olu≈ütu' 
    }
  }
}

// Kategori olu≈ütur
export async function createCategory(formData: CategoryFormData): Promise<ActionResponse<Category>> {
  try {
    const validatedFields = CategorySchema.safeParse(formData)
    
    if (!validatedFields.success) {
      return { 
        success: false, 
        error: 'Ge√ßersiz form verisi', 
        errors: validatedFields.error.flatten().fieldErrors 
      }
    }

    const supabase = await createAdminSupabaseClient()
    
    console.log('üñºÔ∏è Kategori olu≈üturma data:', validatedFields.data)
    console.log('üñºÔ∏è Image URL:', validatedFields.data.image_url)
    
    const { data, error } = await supabase
      .from('categories')
      .insert(validatedFields.data)
      .select()
      .single()

    if (error) throw error

    revalidatePath('/admin/kategoriler')
    revalidatePath('/kategoriler')
    
    return { 
      success: true, 
      data: data as Category,
      message: 'Kategori ba≈üarƒ±yla olu≈üturuldu'
    }
  } catch (error) {
    console.error('Kategori olu≈üturulurken hata:', error)
    return { 
      success: false, 
      error: 'Kategori olu≈üturulurken bir hata olu≈ütu' 
    }
  }
}

// Kategori g√ºncelle
export async function updateCategory(id: string | number, formData: Partial<CategoryFormData>): Promise<ActionResponse<Category>> {
  try {
    console.log('üîÑ Kategori g√ºncelleniyor:', { id, formData })
    console.log('üñºÔ∏è G√ºncelleme - Image URL:', formData.image_url)
    const supabase = await createAdminSupabaseClient()
    
    // ID'yi parse et (UUID veya integer)
    const parsedId = parseId(id)
    
    const { data, error } = await supabase
      .from('categories')
      .update(formData)
      .eq('id', parsedId)
      .select()
      .single()

    if (error) {
      console.error('‚ùå Kategori g√ºncelleme hatasƒ±:', error)
      throw error
    }

    console.log('‚úÖ Kategori ba≈üarƒ±yla g√ºncellendi')
    revalidatePath('/admin/kategoriler')
    revalidatePath('/kategoriler')
    revalidatePath(`/kategoriler/${formData.slug || id}`)
    
    return { 
      success: true, 
      data: data as Category,
      message: 'Kategori ba≈üarƒ±yla g√ºncellendi' 
    }
  } catch (error) {
    console.error('Kategori g√ºncellenirken hata:', error)
    return { 
      success: false, 
      error: 'Kategori g√ºncellenirken bir hata olu≈ütu' 
    }
  }
}

// Kategori sil
export async function deleteCategory(id: string | number): Promise<ActionResponse<null>> {
  try {
    console.log('üóëÔ∏è Kategori siliniyor:', id)
    const supabase = await createAdminSupabaseClient()
    const parsedId = parseId(id)
    console.log('üÜî Parsed ID:', parsedId)
    
    // Alt kategorileri kontrol et
    const { data: children, error: childrenError } = await supabase
      .from('categories')
      .select('id')
      .eq('parent_id', parsedId)

    if (childrenError) {
      console.error('‚ùå Alt kategoriler kontrol hatasƒ±:', childrenError)
      throw childrenError
    }

    if (children && children.length > 0) {
      console.log('‚ö†Ô∏è Alt kategoriler var:', children.length)
      return { 
        success: false, 
        error: 'Bu kategorinin alt kategorileri var. √ñnce alt kategorileri silin.' 
      }
    }

    // √úr√ºnleri kontrol et
    const { data: products, error: productsError } = await supabase
      .from('products')
      .select('id')
      .eq('category_id', parsedId)

    if (productsError) {
      console.error('‚ùå √úr√ºnler kontrol hatasƒ±:', productsError)
      throw productsError
    }

    if (products && products.length > 0) {
      console.log('‚ö†Ô∏è Kategoride √ºr√ºnler var:', products.length)
      return { 
        success: false, 
        error: 'Bu kategoride √ºr√ºnler var. √ñnce √ºr√ºnleri ba≈üka bir kategoriye ta≈üƒ±yƒ±n.' 
      }
    }

    console.log('‚úÖ Kategori silinebilir, siliniyor...')
    const { error } = await supabase
      .from('categories')
      .delete()
      .eq('id', parsedId)

    if (error) {
      console.error('‚ùå Kategori silme hatasƒ±:', error)
      throw error
    }

    console.log('‚úÖ Kategori ba≈üarƒ±yla silindi')
    revalidatePath('/admin/kategoriler')
    revalidatePath('/kategoriler')
    
    return { 
      success: true, 
      data: null,
      message: 'Kategori ba≈üarƒ±yla silindi' 
    }
  } catch (error) {
    console.error('‚ùå Kategori silinirken hata:', error)
    const errorMessage = error instanceof Error ? error.message : 'Kategori silinirken bir hata olu≈ütu'
    return { 
      success: false, 
      error: errorMessage
    }
  }
}

// Slug olu≈ütur
export async function generateSlug(name: string, excludeId?: string | number): Promise<ActionResponse<string>> {
  try {
    const supabase = await createAdminSupabaseClient()
    const baseSlug = createSlug(name)
    let slug = baseSlug
    let counter = 1

    while (true) {
      let query = supabase
        .from('categories')
        .select('id')
        .eq('slug', slug)
      
      // Exclude current category if editing
      if (excludeId) {
        const parsedExcludeId = parseId(excludeId)
        query = query.neq('id', parsedExcludeId)
      }
      
      const { data } = await query

      if (!data || data.length === 0) {
        return { 
          success: true, 
          data: slug,
          message: 'Slug ba≈üarƒ±yla olu≈üturuldu'
        }
      }

      slug = `${baseSlug}-${counter}`
      counter++
    }
  } catch (error) {
    console.error('Slug olu≈üturulurken hata:', error)
    return { 
      success: false, 
      error: 'Slug olu≈üturulurken bir hata olu≈ütu',
      data: createSlug(name)
    }
  }
}

// Kategori istatistikleri
export async function getCategoryStats(categoryId: string | number): Promise<ActionResponse<{
  productCount: number
  activeProductCount: number
  subCategoryCount: number
}>> {
  try {
    const supabase = await createAdminSupabaseClient()
    const parsedId = parseId(categoryId)
    
    const { count: productCount } = await supabase
      .from('products')
      .select('*', { count: 'exact', head: true })
      .eq('category_id', parsedId)

    const activeProductResult = await supabase
      .from('products')
      .select('*', { count: 'exact', head: true })
      .eq('category_id', parsedId)
      .eq('is_active', true)
    
    const { count: activeProductCount } = activeProductResult

    const { data: subCategories } = await supabase
      .from('categories')
      .select('id')
      .eq('parent_id', parsedId)

    return {
      success: true,
      data: {
        productCount: productCount || 0,
        activeProductCount: activeProductCount || 0,
        subCategoryCount: subCategories?.length || 0
      },
      message: 'ƒ∞statistikler ba≈üarƒ±yla y√ºklendi'
    }
  } catch (error) {
    console.error('Kategori istatistikleri alƒ±nƒ±rken hata:', error)
    return { 
      success: false, 
      error: 'ƒ∞statistikler y√ºklenirken bir hata olu≈ütu' 
    }
  }
}

// Helper functions
function buildCategoryTree(categories: CategoryRow[]): Category[] {
  // Early return for empty array
  if (!categories || categories.length === 0) {
    return []
  }

  // Create map and root array explicitly
  const categoryMap: Map<string, Category> = new Map()
  const rootCategories: Category[] = []

  // First pass: Create all category objects
  for (let i = 0; i < categories.length; i++) {
    const cat = categories[i]
    const categoryWithChildren: Category = {
      ...cat,
      children: []
    }
    categoryMap.set(cat.id, categoryWithChildren)
  }

  // Second pass: Build parent-child relationships
  for (let i = 0; i < categories.length; i++) {
    const cat = categories[i]
    const category = categoryMap.get(cat.id)
    
    if (!category) continue
    
    if (cat.parent_id) {
      const parent = categoryMap.get(cat.parent_id)
      if (parent) {
        if (!parent.children) {
          parent.children = []
        }
        parent.children.push(category)
      } else {
        // Parent not found, treat as root
        rootCategories.push(category)
      }
    } else {
      rootCategories.push(category)
    }
  }

  return rootCategories
}

function createSlug(text: string): string {
  return text
    .toString()
    .toLowerCase()
    .trim()
    .replace(/\s+/g, '-')
    .replace(/ƒü/g, 'g')
    .replace(/√º/g, 'u')
    .replace(/≈ü/g, 's')
    .replace(/ƒ±/g, 'i')
    .replace(/√∂/g, 'o')
    .replace(/√ß/g, 'c')
    .replace(/[^\w\-]+/g, '')
    .replace(/\-\-+/g, '-')
} 